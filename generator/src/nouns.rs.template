// -*- mode: rust -*-
//
// This code is generated by the tools in the en-inflexion repo. PRs should
// edit the tools instead of editing this code.
//
// Anything used here must be in the Cargo.toml for the crate, not for the
// generator.

//! Low level functions and data for nouns.
use crate::{
    term::Term,
    util::{to_titlecase, PREPOSITION_REGEX_STR},
};
use once_cell::sync::Lazy;
use regex::Regex;
use std::{
    borrow::Cow,
    collections::{HashMap, HashSet},
};

#[derive(Debug)]
struct Recognizer {
    regex: Regex,
    is_nonindicative: bool,
    recursive_capture_idx: Option<usize>,
}

static PLURAL_POSSESSIVE_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new("(?i).+'s?$").unwrap());
static SINGULAR_POSSESSIVE_REGEX: Lazy<Regex> = Lazy::new(|| Regex::new("(?i).+'s$").unwrap());

static MODERN_PLURAL_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start MODERN_PLURAL_OF
        ("{pair.0}", "{pair.1}"),
        // end MODERN_PLURAL_OF
    ]
    .iter()
    .cloned()
    .collect()
});

// It would be nice to store the replacements in this variable too, but I
// cannot figure out how to do that. The natural way to do this is to store
// pairs of `(regex::Regex, regex::Replacer)`, where the replacer is either a
// string like `"${1}foo"` or a `fn` that takes a `regex::Captures` and
// returns a new string. But the `Replacer` trait cannot be used with `Box<dyn
// Replacer>`. And if I try to make my own `Replacer` enum, the function
// variant needs to be a type like `Box<dyn FnMut(&regex::Captures) ->
// String>`. But the `Captures` type is not `Sync`, so it can't be used with
// `Lazy`!
static SINGULAR_RECOGNIZERS: Lazy<Vec<Recognizer>> = Lazy::new(|| {
    vec![
        // start SINGULAR_RECOGNIZERS
        Recognizer {
            regex: Regex::new("foo").unwrap(),
            is_nonindicative: false,
            special_logic: None,
        },
        // end SINGULAR_RECOGNIZERS
    ]
});

/// Converts a noun to its modern plural form. Whenever possible, this
/// function returns static data or a reference to the string it was given,
/// rather than allocating a new `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "BUSINESSPERSON" you may get
/// odd casing results like "BUSINESSpeople". You are encouraged to always
/// pass words in their poroper case, either lower case or title case as
/// appropriate.
pub fn convert_to_modern_plural(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_modern_plural({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(p) = MODERN_PLURAL_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in MODERN_PLURAL_OF", word);
        return Cow::Borrowed(p);
    }
    if let Some(p) = MODERN_PLURAL_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in MODERN_PLURAL_OF", word);
        return Cow::Borrowed(p);
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = MODERN_PLURAL_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in MODERN_PLURAL_OF", word);
            return Cow::Borrowed(p);
        }
    }

    if is_plural(word) && !is_singular(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already plural and is not singular", word);
        return Cow::Borrowed(word);
    }

    if PLURAL_POSSESSIVE_REGEX.is_match(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' matches plural possessive regex", word);
        return crate::adjective::Adjective::new(word).plural();
    }

    // start SINGULAR_TO_MODERN_PLURAL_TRANSFORMATIONS
    if let Some(caps) = SINGULAR_RECOGNIZERS[0].regex.captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Cow::Owned(new_word);
    }
    // end SINGULAR_TO_MODERN_PLURAL_TRANSFORMATIONS

    #[cfg(feature = "debug")]
    println!("  appending 's' to word '{}' ", word);
    Cow::Owned(add_plural_s(word))
}

static CLASSICAL_PLURAL_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start CLASSICAL_PLURAL_OF
        ("{pair.0}", "{pair.1}"),
        // end CLASSICAL_PLURAL_OF
    ]
    .iter()
    .cloned()
    .collect()
});

/// Converts a noun to its classical plural form. Whenever possible, this
/// function returns static data or a reference to the string it was given,
/// rather than allocating a new `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "BUSINESSPERSON" you may get
/// odd casing results like "BUSINESSpersons". You are encouraged to always
/// pass words in their poroper case, either lower case or title case as
/// appropriate.
pub fn convert_to_classical_plural(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_classical_plural({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(p) = CLASSICAL_PLURAL_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in CLASSICAL_PLURAL_OF", word);
        return Cow::Borrowed(p);
    }
    if let Some(p) = CLASSICAL_PLURAL_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in CLASSICAL_PLURAL_OF", word);
        return Cow::Borrowed(p);
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = CLASSICAL_PLURAL_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in CLASSICAL_PLURAL_OF", word);
            return Cow::Borrowed(p);
        }
    }

    if is_plural(word) && !is_singular(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already plural and is not singular", word);
        return Cow::Owned(word.to_string());
    }

    if PLURAL_POSSESSIVE_REGEX.is_match(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' matches plural possessive regex", word);
        return crate::adjective::Adjective::new(word).plural();
    }

    // start SINGULAR_TO_CLASSICAL_PLURAL_TRANSFORMATIONS
    if let Some(caps) = SINGULAR_RECOGNIZERS[0].regex.captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Cow::Owned(new_word);
    }
    // end SINGULAR_TO_CLASSICAL_PLURAL_TRANSFORMATIONS

    #[cfg(feature = "debug")]
    println!("  appending 's' to word '{}' ", word);
    Cow::Owned(add_plural_s(word))
}

fn add_plural_s(word: &str) -> String {
    let mut plural = word.to_string();
    plural.push('s');
    plural
}

static SINGULAR_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start SINGULAR_OF
        ("{pair.0}", "{pair.1}"),
        // end SINGULAR_OF
    ]
    .iter()
    .cloned()
    .collect()
});

static PLURAL_RECOGNIZERS: Lazy<Vec<Recognizer>> = Lazy::new(|| {
    vec![
        // start PLURAL_RECOGNIZERS
        Recognizer {
            regex: Regex::new("foo").unwrap(),
            is_nonindicative: false,
            special_logic: None,
        },
        // end PLURAL_RECOGNIZERS
    ]
});

/// Converts a noun to its singular form. Whenever possible, this function
/// returns static data or a reference to the string it was given, rather than
/// allocating a new `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "BUSINESSPEOPLE" you may get
/// odd casing results like "BUSINESSperson". You are encouraged to always
/// pass words in their poroper case, either lower case or title case as
/// appropriate.
pub fn convert_to_singular(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_singular({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(s) = SINGULAR_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in SINGULAR_OF", word);
        return Cow::Borrowed(s);
    }
    if let Some(s) = SINGULAR_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in SINGULAR_OF", word);
        return Cow::Borrowed(s);
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = SINGULAR_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in SINGULAR_OF", word);
            return Cow::Borrowed(p);
        }
    }

    if is_singular(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already singular", word);
        return Cow::Borrowed(word);
    }

    if SINGULAR_POSSESSIVE_REGEX.is_match(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' matches singular possessive regex", word);
        return crate::adjective::Adjective::new(word).singular();
    }

    // start PLURAL_TO_SINGULAR_TRANSFORMATIONS
    if let Some(caps) = PLURAL_RECOGNIZERS[0].regex.captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Cow::Owned(new_word);
    }
    // end PLURAL_TO_SINGULAR_TRANSFORMATIONS

    #[cfg(feature = "debug")]
    println!("  trimming 's' from end of word '{}' ", word);
    Cow::Borrowed(word.trim_end_matches(&['s', 'S'][..]))
}

static IS_PLURAL: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_PLURAL
        "word",
        // end IS_PLURAL
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a noun is plural.
pub fn is_plural<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_plural({})", word);

    if IS_PLURAL.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_PLURAL", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_PLURAL.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_PLURAL", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_PLURAL.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_PLURAL", word);
            return true;
        }
    }

    if IS_SINGULAR.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return false;
    }
    if IS_SINGULAR.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return false;
    }
    if let Some(tc_word) = &tc_word {
        if IS_SINGULAR.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return true;
        }
    }

    for r in PLURAL_RECOGNIZERS.iter().filter(|r| !r.is_nonindicative) {
        if let Some(idx) = r.recursive_capture_idx {
            if let Some(caps) = r.regex.captures(word) {
                if let Some(part) = caps.get(idx) {
                    #[cfg(feature = "debug")]
                    println!(
                        "  word '{}' matched recursive logic for recognizer regex {:?}, returning is_plural({})",
                        word, r.regex, part.as_str(),
                    );
                    return is_plural(part.as_str());
                }
            }
        } else if r.regex.is_match(word) {
            #[cfg(feature = "debug")]
            println!(
                "  word '{}' matched plural recognizer regex {:?}",
                word, r.regex,
            );
            return true;
        }
    }

    #[cfg(feature = "debug")]
    println!("  checking if word '{}' ends with 's' or 'S'", word);
    word.ends_with(&['s', 'S'][..])
}

static IS_SINGULAR: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_SINGULAR
        "word",
        // end IS_SINGULAR
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a noun is singular.
pub fn is_singular<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_singular({})", word);

    if IS_SINGULAR.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_SINGULAR.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_SINGULAR.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return true;
        }
    }

    if IS_PLURAL.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_PLURAL", word);
        return false;
    }
    if IS_PLURAL.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_PLURAL", word);
        return false;
    }
    if let Some(tc_word) = &tc_word {
        if IS_PLURAL.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_PLURAL", word);
            return false;
        }
    }

    for r in SINGULAR_RECOGNIZERS.iter().filter(|r| !r.is_nonindicative) {
        if let Some(idx) = r.recursive_capture_idx {
            if let Some(caps) = r.regex.captures(word) {
                if let Some(part) = caps.get(idx) {
                    #[cfg(feature = "debug")]
                    println!(
                        "  word '{}' matched recursive logic for recognizer regex {:?}, returning is_singular({})",
                        word, r.regex, part.as_str(),
                    );
                    return is_singular(part.as_str());
                }
            }
        } else if r.regex.is_match(word) {
            #[cfg(feature = "debug")]
            println!(
                "  word '{}' matched singular recognizer regex {:?}",
                word, r.regex,
            );
            return true;
        }
    }

    #[cfg(feature = "debug")]
    println!("  returning !is_plural({})", word);
    !is_plural(word)
}

#[cfg(test)]
mod tests {
    use std::borrow::Cow;

    // CONVERSIONS_TEST_DATA

    #[test]
    fn conversions() {
        for mut line in CONVERSIONS_TEST_DATA
            .lines()
            .filter(|l| !(l.is_empty() || l.contains('#')))
        {
            // An ambiguous word is one where the coversion from classical to
            // singular produces a different word than the original
            // singular. An example is staff (S) -> staves (CP) -> stave (S).
            let is_ambiguous = if line.starts_with('!') {
                line = line.strip_prefix("! ").unwrap();
                true
            } else {
                false
            };
            let inflections = line
                .split('|')
                .map(str::trim)
                .filter(|s| !s.is_empty())
                .collect::<Vec<&str>>();
            let singular = inflections[0];
            let mut modern_plural = inflections[1].to_string();
            let classical_plural = inflections.get(2);
            let singular_from_classical = inflections.get(3).unwrap_or(&singular);

            if modern_plural.is_empty() {
                if classical_plural.is_none() {
                    panic!("line does not have any plurals: [{}]", line);
                }
                modern_plural = classical_plural.unwrap().to_string();
            }
            let classical_plural = classical_plural
                .map(|cp| cp.to_string())
                .unwrap_or_else(|| modern_plural.clone());

            test_one_conversion(
                "singular",
                "modern plural",
                singular,
                &modern_plural,
                super::convert_to_modern_plural,
            );
            test_one_conversion(
                "modern plural",
                "modern plural",
                &modern_plural,
                &modern_plural,
                super::convert_to_modern_plural,
            );

            test_one_conversion(
                "singular",
                "classical plural",
                singular,
                &classical_plural,
                super::convert_to_classical_plural,
            );
            test_one_conversion(
                "classical plural",
                "classical plural",
                &classical_plural,
                &classical_plural,
                super::convert_to_classical_plural,
            );

            test_one_conversion(
                "singular",
                "singular",
                singular,
                singular,
                super::convert_to_singular,
            );
            test_one_conversion(
                "modern plural",
                "singular",
                &modern_plural,
                singular,
                super::convert_to_singular,
            );
            if !is_ambiguous {
                test_one_conversion(
                    "classical plural",
                    "singular",
                    &classical_plural,
                    singular_from_classical,
                    super::convert_to_singular,
                );
            }
        }
    }

    fn test_one_conversion<A, F>(from: &str, to: &str, word: A, expect: &str, conv: F)
    where
        A: AsRef<str>,
        F: Fn(&str) -> Cow<'_, str>,
    {
        let word = word.as_ref();
        assert_eq!(
            conv(word),
            expect,
            "from {from} convert_to_{to}({word}) = {expect}",
            from = from,
            to = to,
            word = word,
            expect = expect,
        );

        let word = word.to_uppercase();
        assert_eq!(
            conv(word.as_str()).to_lowercase(),
            expect.to_lowercase(),
            "from {from} convert_to_{to}({word}) = {expect}",
            from = from,
            to = to,
            word = word.as_str(),
            expect = expect,
        );

        let word = super::to_titlecase(&word);
        assert_eq!(
            conv(word.as_str()).to_lowercase(),
            expect.to_lowercase(),
            "from {from} convert_to_{to}({word}) = {expect}",
            from = from,
            to = to,
            word = word.as_str(),
            expect = expect,
        );
    }

    #[test]
    fn is_plural() {
        for word in super::IS_PLURAL.iter() {
            assert!(super::is_plural(word), "is_plural({}) is true", word);
        }
    }

    #[test]
    fn is_singular() {
        for word in super::IS_SINGULAR.iter() {
            assert!(super::is_singular(word), "is_singular({}) is true", word);
        }
    }
}
