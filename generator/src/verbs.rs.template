// -*- mode: rust -*-
//
// This code is generated by the tools in the en-inflexion repo. PRs should
// edit the tools instead of editing this code.
//
// Anything used here must be in the Cargo.toml for the crate, not for the
// generator.

//! Low level functions and data for verbs.
use crate::util::to_titlecase;
use once_cell::sync::Lazy;
use regex::Regex;
use std::{
    borrow::Cow,
    collections::{HashMap, HashSet},
};

static PLURAL_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start PLURAL_OF
        ("{pair.0}", "{pair.1}"),
        // end PLURAL_OF
    ]
    .iter()
    .cloned()
    .collect()
});

static SINGULAR_RECOGNIZER_REGEXES: Lazy<Vec<Regex>> = Lazy::new(|| {
    vec![
        // start SINGULAR_RECOGNIZER_REGEXES
        Regex::new("foo").unwrap(),
        // end SINGULAR_RECOGNIZER_REGEXES
    ]
});

/// Converts a verb to its modern plural form. Whenever possible, this
/// function returns static data or a reference to the string it was given,
/// rather than allocating a new `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "EAT" you may get odd casing
/// results like "EATs". You are encouraged to always pass words in their
/// poroper case, either lower case or title case as appropriate.
pub fn convert_to_plural(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_plural({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(p) = PLURAL_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in PLURAL_OF", word);
        return Cow::Borrowed(p);
    }
    if let Some(p) = PLURAL_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in PLURAL_OF", word);
        return Cow::Borrowed(p);
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = PLURAL_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in PLURAL_OF", word);
            return Cow::Borrowed(p);
        }
    }

    // start SINGULAR_TO_PLURAL_TRANSFORMATIONS
    if let Some(caps) = SINGULAR_RECOGNIZER_REGEXES[0].captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Cow::Owned(new_word);
    }
    // end SINGULAR_TO_PLURAL_TRANSFORMATIONS

    if is_plural(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already plural", word);
        return Cow::Borrowed(word);
    }

    #[cfg(feature = "debug")]
    println!("  word '{}' does not have a conversion to plural", word);
    Cow::Borrowed("_")
}

static SINGULAR_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start SINGULAR_OF
        ("{pair.0}", "{pair.1}"),
        // end SINGULAR_OF
    ]
    .iter()
    .cloned()
    .collect()
});

static PLURAL_RECOGNIZER_REGEXES: Lazy<Vec<Regex>> = Lazy::new(|| {
    vec![
        // start PLURAL_RECOGNIZER_REGEXES
        Regex::new("foo").unwrap(),
        // end PLURAL_RECOGNIZER_REGEXES
    ]
});

/// Converts a verb to its singular form. Whenever possible, this function
/// returns static data or a reference to the string it was given, rather than
/// allocating a new `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "EAT" you may get odd casing
/// results like "EATs". You are encouraged to always pass words in their
/// poroper case, either lower case or title case as appropriate.
pub fn convert_to_singular(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_singular");

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(s) = SINGULAR_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in SINGULAR_OF", word);
        return Cow::Borrowed(s);
    }
    if let Some(s) = SINGULAR_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in SINGULAR_OF", word);
        return Cow::Borrowed(s);
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = SINGULAR_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in SINGULAR_OF", word);
            return Cow::Borrowed(p);
        }
    }

    // start PLURAL_TO_SINGULAR_TRANSFORMATIONS
    if let Some(caps) = PLURAL_RECOGNIZER_REGEXES[0].captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Cow::Owned(new_word);
    }
    // end PLURAL_TO_SINGULAR_TRANSFORMATIONS

    if is_singular(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already singular", word);
        return Cow::Borrowed(word);
    }

    #[cfg(feature = "debug")]
    println!("  word '{}' does not have a conversion to singular", word);
    Cow::Borrowed(word)
}

static PAST_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start PAST_OF
        ("{pair.0}", "{pair.1}"),
        // end PAST_OF
    ]
    .iter()
    .cloned()
    .collect()
});

static PAST_RECOGNIZER_REGEXES: Lazy<Vec<Regex>> = Lazy::new(|| {
    vec![
        // start PAST_RECOGNIZER_REGEXES
        Regex::new("foo").unwrap(),
        // end PAST_RECOGNIZER_REGEXES
    ]
});

/// Converts a verb to its past form, like "ate", "ran", "or
/// "walked". Whenever possible, this function returns static data or a
/// reference to the string it was given, rather than allocating a new
/// `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "WALK" you may get odd
/// casing results like "WALKed". You are encouraged to always pass words in
/// their poroper case, either lower case or title case as appropriate.
pub fn convert_to_past(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_past({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(past) = maybe_convert_to_past(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' converted to past as '{}'", word, past);
        return past;
    }

    let root = convert_to_plural(word);
    #[cfg(feature = "debug")]
    println!(
        "  trying root (plural) of word '{}', which is '{}'",
        word, root
    );
    if let Some(past) = maybe_convert_to_past(&root) {
        #[cfg(feature = "debug")]
        println!("  plural word '{}' converted to past as '{}'", root, past);
        // Since convert_to_plural may have returned a Cow::Borrowed using
        // &root, we can't just return a Cow::Borrowed which borrows that
        // data, as `root` is about to go out of scope.
        return Cow::Owned(past.into_owned());
    }

    #[cfg(feature = "debug")]
    println!(
        "  appending 'ed' to truncated word '{}'",
        truncate(root.as_ref())
    );
    Cow::Owned(format!("{}ed", truncate(root.as_ref())))
}

fn maybe_convert_to_past(word: &str) -> Option<Cow<'_, str>> {
    if let Some(p) = PAST_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in PAST_OF", word);
        return Some(Cow::Borrowed(p));
    }
    if let Some(p) = PAST_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in PAST_OF", word);
        return Some(Cow::Borrowed(p));
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = PAST_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in PAST_OF", word);
            return Some(Cow::Borrowed(p));
        }
    }

    // start TO_PAST_TRANSFORMATIONS
    if let Some(caps) = PLURAL_RECOGNIZER_REGEXES[0].captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Some(Cow::Owned(new_word));
    }
    // end TO_PAST_TRANSFORMATIONS

    if is_past(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already past", word);
        return Some(Cow::Borrowed(word));
    }

    #[cfg(feature = "debug")]
    println!(
        "  word '{}' does not have a custom conversion to past",
        word
    );
    None
}

static PRESENT_PARTICIPLE_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start PRESENT_PARTICIPLE_OF
        ("{pair.0}", "{pair.1}"),
        // end PRESENT_PARTICIPLE_OF
    ]
    .iter()
    .cloned()
    .collect()
});

static PRESENT_PARTICIPLE_RECOGNIZER_REGEXES: Lazy<Vec<Regex>> = Lazy::new(|| {
    vec![
        // start PRESENT_PARTICIPLE_RECOGNIZER_REGEXES
        Regex::new("foo").unwrap(),
        // end PRESENT_PARTICIPLE_RECOGNIZER_REGEXES
    ]
});

/// Converts a verb to its present participle form, like "eating, "running",
/// or "walking". Whenever possible, this function returns static data or a
/// reference to the string it was given, rather than allocating a new
/// `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "EAT" you may get odd casing
/// results like "EATing". You are encouraged to always pass words in their
/// poroper case, either lower case or title case as appropriate.
pub fn convert_to_present_participle(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_present_participle({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(present) = maybe_convert_to_present_participle(word) {
        #[cfg(feature = "debug")]
        println!(
            "  word '{}' converted to present participle as '{}'",
            word, present
        );
        return present;
    }

    let root = convert_to_plural(word);
    #[cfg(feature = "debug")]
    println!(
        "  trying root (plural) of word '{}', which is '{}'",
        word, root,
    );
    if let Some(present) = maybe_convert_to_present_participle(&root) {
        #[cfg(feature = "debug")]
        println!(
            "  plural word '{}' converted to present participle as '{}'",
            root, present
        );
        // Since convert_to_plural may have returned a Cow::Borrowed using
        // &root, we can't just return a Cow::Borrowed which borrows that
        // data, as `root` is about to go out of scope.
        return Cow::Owned(present.into_owned());
    }

    #[cfg(feature = "debug")]
    println!(
        "  appending 'ing' to truncated word '{}'",
        truncate(root.as_ref())
    );
    Cow::Owned(format!("{}ing", truncate(root.as_ref())))
}

fn maybe_convert_to_present_participle(word: &str) -> Option<Cow<'_, str>> {
    if let Some(p) = PRESENT_PARTICIPLE_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in PRESENT_PARTICIPLE_OF", word);
        return Some(Cow::Borrowed(p));
    }
    if let Some(p) = PRESENT_PARTICIPLE_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in PRESENT_PARTICIPLE_OF", word);
        return Some(Cow::Borrowed(p));
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = PRESENT_PARTICIPLE_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in PRESENT_PARTICIPLE_OF", word);
            return Some(Cow::Borrowed(p));
        }
    }

    // start TO_PRESENT_PARTICIPLE_TRANSFORMATIONS
    if let Some(caps) = PLURAL_RECOGNIZER_REGEXES[0].captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Some(Cow::Owned(new_word));
    }
    // end TO_PRESENT_PARTICIPLE_TRANSFORMATIONS

    if is_present_participle(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already present participle", word);
        return Some(Cow::Borrowed(word));
    }

    #[cfg(feature = "debug")]
    println!(
        "  word '{}' does not have a custom conversion to present participle",
        word,
    );
    None
}

static PAST_PARTICIPLE_OF: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {
    [
        // start PAST_PARTICIPLE_OF
        ("{pair.0}", "{pair.1}"),
        // end PAST_PARTICIPLE_OF
    ]
    .iter()
    .cloned()
    .collect()
});

static PAST_PARTICIPLE_RECOGNIZER_REGEXES: Lazy<Vec<Regex>> = Lazy::new(|| {
    vec![
        // start PAST_PARTICIPLE_RECOGNIZER_REGEXES
        Regex::new("foo").unwrap(),
        // end PAST_PARTICIPLE_RECOGNIZER_REGEXES
    ]
});

/// Converts a verb to its past participle form, like "(I have) eaten, "(I
/// have) run", or "(I have) walked". Whenever possible, this function returns
/// static data or a reference to the string it was given, rather than
/// allocating a new `String`.
///
/// The case of the returned word will not necessarily match the case of the
/// original word, and when given shout case like "WALK" you may get odd
/// casing results like "WALKed". You are encouraged to always pass words in
/// their poroper case, either lower case or title case as appropriate.
pub fn convert_to_past_participle(word: &str) -> Cow<'_, str> {
    #[cfg(feature = "debug")]
    println!("convert_to_past_participle({})", word);

    if word.is_empty() {
        #[cfg(feature = "debug")]
        println!("  word is empty");
        return Cow::Borrowed("");
    }

    if let Some(past) = maybe_convert_to_past_participle(word) {
        #[cfg(feature = "debug")]
        println!(
            "  word '{}' converted to past participle as '{}'",
            word, past
        );
        return past;
    }

    let root = convert_to_plural(word);
    #[cfg(feature = "debug")]
    println!(
        "  trying root (plural) of word '{}', which is '{}'",
        word, root
    );
    if let Some(past) = maybe_convert_to_past_participle(&root) {
        #[cfg(feature = "debug")]
        println!(
            "  plural word '{}' converted to past participle as '{}'",
            root, past
        );
        // Since convert_to_plural may have returned a Cow::Borrowed using
        // &root, we can't just return a Cow::Borrowed which borrows that
        // data, as `root` is about to go out of scope.
        return Cow::Owned(past.into_owned());
    }

    #[cfg(feature = "debug")]
    println!(
        "  appending 'ed' to truncated word '{}'",
        truncate(root.as_ref())
    );
    Cow::Owned(format!("{}ed", truncate(root.as_ref())))
}

fn maybe_convert_to_past_participle(word: &str) -> Option<Cow<'_, str>> {
    if let Some(p) = PAST_PARTICIPLE_OF.get(word) {
        #[cfg(feature = "debug")]
        println!("  found word '{}' in PAST_PARTICIPLE_OF", word);
        return Some(Cow::Borrowed(p));
    }
    if let Some(p) = PAST_PARTICIPLE_OF.get(word.to_lowercase().as_str()) {
        #[cfg(feature = "debug")]
        println!("  found lc word '{}' in PAST_PARTICIPLE_OF", word);
        return Some(Cow::Borrowed(p));
    }
    if word.len() > 1 {
        let tc_word = to_titlecase(word);
        if let Some(p) = PAST_PARTICIPLE_OF.get(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc word '{}' in PAST_PARTICIPLE_OF", word);
            return Some(Cow::Borrowed(p));
        }
    }

    // start TO_PAST_PARTICIPLE_TRANSFORMATIONS
    if let Some(caps) = PLURAL_RECOGNIZER_REGEXES[0].captures(word) {
        let mut new_word = String::new();
        caps.expand("${1}bar", &mut new_word);
        return Some(Cow::Owned(new_word));
    }
    // end TO_PAST_PARTICIPLE_TRANSFORMATIONS

    if is_past_participle(word) {
        #[cfg(feature = "debug")]
        println!("  word '{}' is already past participle", word);
        return Some(Cow::Borrowed(word));
    }

    #[cfg(feature = "debug")]
    println!(
        "  word '{}' does not have a custom conversion to past participle",
        word
    );
    None
}

static TRUNCATIONS: Lazy<Vec<(Regex, Option<&str>)>> = Lazy::new(|| {
    vec![
        (Regex::new(r"(?i)(.+)ie$").unwrap(), Some("$1y")),
        (Regex::new(r"(?i)(.+)ue$").unwrap(), Some("$1u")),
        (Regex::new(r"(?i)(.+[auy])e$").unwrap(), Some("$1")),
        (Regex::new(r"(?i)ski$").unwrap(), None),
        (Regex::new(r"(?i)(.+)[^b]i$").unwrap(), Some("$1")),
        (Regex::new(r"(?i)([^e])e$").unwrap(), Some("$1")),
        (Regex::new(r"(?i)er$").unwrap(), None),
        (
            Regex::new(r"(?i)(.*[bdghklmnprstz][o]([n]))$").unwrap(),
            Some("$1"),
        ),
        (
            Regex::new(r"(?i)(.*[^aeiou][aeiouy]([bcdlgmnprstv]))$").unwrap(),
            Some("$1$2"),
        ),
        (Regex::new(r"(?i)(.+)e$").unwrap(), Some("$1")),
    ]
});

fn truncate(word: &str) -> Cow<'_, str> {
    for pair in TRUNCATIONS.iter() {
        if let Some(caps) = pair.0.captures(word) {
            return match pair.1 {
                Some(replacement) => {
                    let mut new_word = String::new();
                    caps.expand(replacement, &mut new_word);
                    Cow::Owned(new_word)
                }
                None => Cow::Borrowed(word),
            };
        }
    }

    Cow::Borrowed(word)
}

static IS_PLURAL: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_PLURAL
        "word",
        // end IS_PLURAL
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a verb is plural.
pub fn is_plural<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_plural({})", word);

    if IS_PLURAL.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_PLURAL", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_PLURAL.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_PLURAL", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_PLURAL.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_PLURAL", word);
            return true;
        }
    }

    if IS_SINGULAR.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return false;
    }
    if IS_SINGULAR.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return false;
    }
    if let Some(tc_word) = &tc_word {
        if IS_SINGULAR.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return false;
        }
    }

    for re in PLURAL_RECOGNIZER_REGEXES.iter() {
        if re.is_match(word) {
            #[cfg(feature = "debug")]
            println!("  word '{}' matched plural recognizer regex {:?}", word, re);
            return true;
        }
    }

    false
}

static IS_SINGULAR: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_SINGULAR
        "word",
        // end IS_SINGULAR
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a verb is singular.
pub fn is_singular<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_singular");

    if IS_SINGULAR.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_SINGULAR.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_SINGULAR.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return true;
        }
    }

    if IS_PLURAL.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_PLURAL", word);
        return false;
    }
    if IS_PLURAL.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_PLURAL", word);
        return false;
    }
    if let Some(tc_word) = &tc_word {
        if IS_PLURAL.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_PLURAL", word);
            return false;
        }
    }

    for re in SINGULAR_RECOGNIZER_REGEXES.iter() {
        if re.is_match(word) {
            #[cfg(feature = "debug")]
            println!(
                "  word '{}' matched singular recognizer regex {:?}",
                word, re,
            );
            return true;
        }
    }

    #[cfg(feature = "debug")]
    println!("  returning !is_plural({})", word);
    !is_plural(word)
}

static IS_PAST: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_PAST
        "word",
        // end IS_PAST
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a verb is in past tense.
pub fn is_past<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_past({})", word);

    if IS_PAST.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_PAST.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_PAST.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return true;
        }
    }

    for re in PAST_RECOGNIZER_REGEXES.iter() {
        if re.is_match(word) {
            #[cfg(feature = "debug")]
            println!("  word '{}' matched past recognizer regex {:?}", word, re,);
            return true;
        }
    }

    #[cfg(feature = "debug")]
    println!("  returning false");
    false
}

static IS_PRESENT_PARTICIPLE: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_PRESENT_PARTICIPLE
        "word",
        // end IS_PRESENT_PARTICIPLE
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a verb is in present participle
/// tense.
pub fn is_present_participle<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_present_participle({})", word);

    if IS_PRESENT_PARTICIPLE.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_PRESENT_PARTICIPLE.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_PRESENT_PARTICIPLE.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return true;
        }
    }

    for re in PRESENT_PARTICIPLE_RECOGNIZER_REGEXES.iter() {
        if re.is_match(word) {
            #[cfg(feature = "debug")]
            println!(
                "  word '{}' matched present participle recognizer regex {:?}",
                word, re,
            );
            return true;
        }
    }

    #[cfg(feature = "debug")]
    println!("  returning false");
    false
}

static IS_PAST_PARTICIPLE: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    [
        // start IS_PAST_PARTICIPLE
        "word",
        // end IS_PAST_PARTICIPLE
    ]
    .iter()
    .cloned()
    .collect()
});

/// Returns true or false indicating whether a verb is in past participle
/// tense.
pub fn is_past_participle<A: AsRef<str>>(word: A) -> bool {
    let word = word.as_ref();
    #[cfg(feature = "debug")]
    println!("is_past_participle({})", word);

    if IS_PAST_PARTICIPLE.contains(word) {
        #[cfg(feature = "debug")]
        println!("  found '{}' in IS_SINGULAR", word);
        return true;
    }
    let lc_word = word.to_lowercase();
    if IS_PAST_PARTICIPLE.contains(&*lc_word) {
        #[cfg(feature = "debug")]
        println!("  found lc '{}' in IS_SINGULAR", word);
        return true;
    }
    let tc_word = if word.len() > 1 {
        Some(to_titlecase(word))
    } else {
        None
    };
    if let Some(tc_word) = &tc_word {
        if IS_PAST_PARTICIPLE.contains(tc_word.as_str()) {
            #[cfg(feature = "debug")]
            println!("  found tc '{}' in IS_SINGULAR", word);
            return true;
        }
    }

    for re in PAST_PARTICIPLE_RECOGNIZER_REGEXES.iter() {
        if re.is_match(word) {
            #[cfg(feature = "debug")]
            println!(
                "  word '{}' matched past participle recognizer regex {:?}",
                word, re,
            );
            return true;
        }
    }

    #[cfg(feature = "debug")]
    println!("  returning false");
    false
}

#[cfg(test)]
mod tests {
    use std::borrow::Cow;

    #[test]
    fn convert_to_plural() {
        let mut pairs = super::PLURAL_OF
            .clone()
            .into_iter()
            .collect::<Vec<(&str, &str)>>();
        // I want the tests to run in the same order every time.
        pairs.sort_by_key(|p| p.0.to_lowercase());

        for (word, plural) in pairs {
            test_one_conversion(
                "word in PLURAL_OF",
                "plural",
                word,
                plural,
                super::convert_to_plural,
            );
        }
    }

    #[test]
    fn convert_to_singular() {
        let mut pairs = super::SINGULAR_OF
            .clone()
            .into_iter()
            .collect::<Vec<(&str, &str)>>();
        // I want the tests to run in the same order every time.
        pairs.sort_by_key(|p| p.0.to_lowercase());

        for (word, singular) in pairs {
            test_one_conversion(
                "word in SINGULAR_OF",
                "singular",
                word,
                singular,
                super::convert_to_singular,
            );
        }
    }

    #[test]
    fn convert_to_past() {
        let mut pairs = super::PAST_OF
            .clone()
            .into_iter()
            .collect::<Vec<(&str, &str)>>();
        // I want the tests to run in the same order every time.
        pairs.sort_by_key(|p| p.0.to_lowercase());

        for (word, past) in pairs {
            test_one_conversion(
                "word in PAST_OF",
                "past",
                word,
                past,
                super::convert_to_past,
            );
        }
    }

    #[test]
    fn convert_to_present_participle() {
        let mut pairs = super::PRESENT_PARTICIPLE_OF
            .clone()
            .into_iter()
            .collect::<Vec<(&str, &str)>>();
        // I want the tests to run in the same order every time.
        pairs.sort_by_key(|p| p.0.to_lowercase());

        for (word, present_participle) in pairs {
            test_one_conversion(
                "word in PRESENT_PARTICIPLE_OF",
                "present_participle",
                word,
                present_participle,
                super::convert_to_present_participle,
            );
        }
    }

    #[test]
    fn convert_to_past_participle() {
        let mut pairs = super::PAST_PARTICIPLE_OF
            .clone()
            .into_iter()
            .collect::<Vec<(&str, &str)>>();
        // I want the tests to run in the same order every time.
        pairs.sort_by_key(|p| p.0.to_lowercase());

        for (word, past_participle) in pairs {
            test_one_conversion(
                "word in PAST_PARTICIPLE_OF",
                "past_participle",
                word,
                past_participle,
                super::convert_to_past_participle,
            );
        }
    }

    // CONVERSIONS_TEST_DATA

    #[test]
    fn conversions() {
        for line in CONVERSIONS_TEST_DATA
            .lines()
            .filter(|l| !(l.is_empty() || l.contains('#')))
        {
            let inflections = line.split_whitespace().collect::<Vec<&str>>();
            let singular = inflections[0];
            let plural = inflections[1];
            let past = inflections[2];
            let present_participle = inflections[3];
            let past_participle = inflections[4];

            test_one_conversion(
                "singular",
                "singular",
                singular,
                singular,
                super::convert_to_singular,
            );
            test_one_conversion(
                "plural",
                "singular",
                plural,
                singular,
                super::convert_to_singular,
            );

            test_one_conversion(
                "singular",
                "plural",
                singular,
                plural,
                super::convert_to_plural,
            );
            test_one_conversion("plural", "plural", plural, plural, super::convert_to_plural);

            test_one_conversion("singular", "past", singular, past, super::convert_to_past);
            test_one_conversion("plural", "past", plural, past, super::convert_to_past);

            if present_participle != "-" {
                test_one_conversion(
                    "singular",
                    "present_participle",
                    singular,
                    present_participle,
                    super::convert_to_present_participle,
                );
                test_one_conversion(
                    "plural",
                    "present_participle",
                    plural,
                    present_participle,
                    super::convert_to_present_participle,
                );
            }

            if past_participle != "-" {
                test_one_conversion(
                    "singular",
                    "past_participle",
                    singular,
                    past_participle,
                    super::convert_to_past_participle,
                );
                test_one_conversion(
                    "plural",
                    "past_participle",
                    plural,
                    past_participle,
                    super::convert_to_past_participle,
                );
            }
        }
    }

    fn test_one_conversion<A, F>(from: &str, to: &str, word: A, expect: &str, conv: F)
    where
        A: AsRef<str>,
        F: Fn(&str) -> Cow<'_, str>,
    {
        let word = word.as_ref();
        assert_eq!(
            conv(word),
            expect,
            "from {from} convert_to_{to}({word}) = {expect}",
            from = from,
            to = to,
            word = word,
            expect = expect,
        );

        let word = word.to_uppercase();
        assert_eq!(
            conv(word.as_str()).to_lowercase(),
            expect.to_lowercase(),
            "from {from} convert_to_{to}({word}) = {expect}",
            from = from,
            to = to,
            word = word.as_str(),
            expect = expect,
        );

        let word = super::to_titlecase(&word);
        assert_eq!(
            conv(word.as_str()).to_lowercase(),
            expect.to_lowercase(),
            "from {from} convert_to_{to}({word}) = {expect}",
            from = from,
            to = to,
            word = word.as_str(),
            expect = expect,
        );
    }

    #[test]
    fn is_plural() {
        for word in super::IS_PLURAL.iter() {
            assert!(super::is_plural(word), "is_plural({}) is true", word);
            let word = word.to_uppercase();
            assert!(super::is_plural(&word), "is_plural({}) is true", word);
            let word = super::to_titlecase(&word);
            assert!(super::is_plural(&word), "is_plural({}) is true", word);
        }
    }

    #[test]
    fn is_singular() {
        for word in super::IS_SINGULAR.iter() {
            assert!(super::is_singular(word), "is_singular({}) is true", word);
            let word = word.to_uppercase();
            assert!(super::is_singular(&word), "is_singular({}) is true", word);
            let word = super::to_titlecase(&word);
            assert!(super::is_singular(&word), "is_singular({}) is true", word);
        }
    }

    #[test]
    fn is_past() {
        for word in super::IS_PAST.iter() {
            assert!(super::is_past(word), "is_past({}) is true", word);
            let word = word.to_uppercase();
            assert!(super::is_past(&word), "is_past({}) is true", word);
            let word = super::to_titlecase(&word);
            assert!(super::is_past(&word), "is_past({}) is true", word);
        }
    }

    #[test]
    fn is_present_participle() {
        for word in super::IS_PRESENT_PARTICIPLE.iter() {
            assert!(
                super::is_present_participle(word),
                "is_present_participle({}) is true",
                word
            );
            let word = word.to_uppercase();
            assert!(
                super::is_present_participle(&word),
                "is_present_participle({}) is true",
                word
            );
            let word = super::to_titlecase(&word);
            assert!(
                super::is_present_participle(&word),
                "is_present_participle({}) is true",
                word
            );
        }
    }

    #[test]
    fn is_past_participle() {
        for word in super::IS_PAST_PARTICIPLE.iter() {
            assert!(
                super::is_past_participle(word),
                "is_past_participle({}) is true",
                word
            );
            let word = word.to_uppercase();
            assert!(
                super::is_past_participle(&word),
                "is_past_participle({}) is true",
                word
            );
            let word = super::to_titlecase(&word);
            assert!(
                super::is_past_participle(&word),
                "is_past_participle({}) is true",
                word
            );
        }
    }
}
